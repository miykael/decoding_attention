"""
2D Shape Dataset for Vision Transformer Demos

This module generates synthetic RGB images (using PIL) containing non-overlapping shapes.
Shapes include: filled_circle, hollow_circle, filled_rectangle, hollow_rectangle,
filled_triangle, and hollow_triangle.
Each sample is an image (default size 128x128) with 2 to 4 distinct shape types chosen randomly.
For each chosen shape type, 1 to 3 occurrences are generated, each with its own randomly assigned color
(from a discrete set of base colors, which are varied slightly).

The input image is drawn with the shapes using their individual colors and with added smooth noise.
The target image is generated by redrawing the shapes using the group-average color for each shape type.
When draw_all_targets is False, a filtering is applied so that only shapes whose input colors satisfy
the channel criteria (triangles: red > 128, rectangles: green >= 128, circles: blue >= 128)
are drawn in the target image. As an additional safeguard, the dataset forces at least one valid shape per
group by adjusting one shape's color if necessary.

This dataset can be used to illustrate tokenization (by splitting the image into patches),
positional encoding, and how an encoder-decoder Transformer with cross-attention processes visual tokens.
"""

import random
import numpy as np
from math import sqrt
from PIL import Image, ImageDraw, ImageFilter
import matplotlib.pyplot as plt
import torch

# Import configuration parameters from config
from config import (
    IMAGE_HEIGHT,
    IMAGE_WIDTH,
    SHAPE_MIN_RADIUS,
    SHAPE_MAX_RADIUS,
    SHAPE_MIN_RECT_SIZE,
    SHAPE_MAX_RECT_SIZE,
    SHAPE_MIN_TRI_SIZE,
    SHAPE_MAX_TRI_SIZE,
    SHAPE_HOLLOW_MIN_THICKNESS,
    SHAPE_HOLLOW_MAX_THICKNESS,
    SHAPE_COLOR_VARIATION,
    SHAPE_NOISE_STD,
    SHAPE_NOISE_SIGMA,
)

# Allowed shape types
ALLOWED_SHAPES = [
    "filled_circle",
    "hollow_circle",
    "filled_rectangle",
    "hollow_rectangle",
    "filled_triangle",
    "hollow_triangle",
]

# Base color templates (RGB)
ALLOWED_COLORS_TEMPLATE = [
    (255, 0, 0),  # Red only
    (0, 255, 0),  # Green only
    (0, 0, 255),  # Blue only
    (255, 255, 0),  # Yellow (Red + Green)
    (255, 0, 255),  # Magenta (Red + Blue)
    (0, 255, 255),  # Cyan (Green + Blue)
]


def get_varied_color(color_template: tuple) -> tuple:
    """
    Generate a color by introducing slight variations to a given template color.

    Args:
        color_template: The base RGB color as a tuple.

    Returns:
        A tuple representing the varied RGB color, with values clamped between 0 and 255.
    """
    variations: np.ndarray = np.random.uniform(
        -SHAPE_COLOR_VARIATION, SHAPE_COLOR_VARIATION, 3
    )
    varied_color: tuple = tuple(
        int(np.clip(c + v, 0, 255)) for c, v in zip(color_template, variations)
    )
    return varied_color


def is_overlapping(new_region: tuple, regions: list) -> bool:
    """
    Check if new_region overlaps any region in the list of regions.

    Args:
        new_region: Tuple (x_min, y_min, x_max, y_max) defining the new region.
        regions: List of existing regions defined similarly.

    Returns:
        True if there is an overlap; otherwise, False.
    """
    x_min, y_min, x_max, y_max = new_region
    for a, b, c, d in regions:
        if not (x_max <= a or x_min >= c or y_max <= b or y_min >= d):
            return True
    return False


def add_noise(
    image: Image.Image,
    noise_std: float = SHAPE_NOISE_STD,
    sigma: float = SHAPE_NOISE_SIGMA,
) -> Image.Image:
    """
    Add smooth Gaussian noise to a PIL image.

    Noise is added by introducing random variations to the image pixels, then smoothing the result with a Gaussian blur.

    Args:
        image: Input PIL image.
        noise_std: Standard deviation for the noise.
        sigma: Radius for the Gaussian blur to smooth the noise.

    Returns:
        Noisy image as a PIL image.
    """
    # Convert image to a NumPy array for noise addition
    arr: np.ndarray = np.array(image).astype(np.float32)
    noise: np.ndarray = np.random.normal(0, noise_std, arr.shape).astype(np.float32)
    noisy_arr: np.ndarray = arr + noise
    noisy_arr = np.clip(noisy_arr, 0, 255).astype(np.uint8)
    noisy_image: Image.Image = Image.fromarray(noisy_arr)
    # Apply Gaussian blur using PIL's ImageFilter
    noisy_image = noisy_image.filter(ImageFilter.GaussianBlur(radius=sigma))
    return noisy_image


def draw_filled_circle(
    img: Image.Image, center: tuple, radius: int, color: tuple
) -> None:
    """
    Draw a filled circle on a PIL image.

    Args:
        img: The PIL image on which to draw.
        center: Center coordinates (x, y) of the circle.
        radius: Radius of the circle.
        color: RGB color tuple.
    """
    draw = ImageDraw.Draw(img)
    bbox = (
        center[0] - radius,
        center[1] - radius,
        center[0] + radius,
        center[1] + radius,
    )
    draw.ellipse(bbox, fill=color)


def draw_hollow_circle(
    img: Image.Image, center: tuple, radius: int, color: tuple, thickness: int = 2
) -> None:
    """
    Draw a hollow circle (outlined) on a PIL image.

    Args:
        img: The PIL image on which to draw.
        center: Center coordinates (x, y) of the circle.
        radius: Radius of the circle.
        color: RGB color tuple.
        thickness: Outline thickness.
    """
    draw = ImageDraw.Draw(img)
    bbox = (
        center[0] - radius,
        center[1] - radius,
        center[0] + radius,
        center[1] + radius,
    )
    draw.ellipse(bbox, outline=color, width=thickness)


def draw_filled_rectangle(
    img: Image.Image, pt1: tuple, pt2: tuple, color: tuple
) -> None:
    """
    Draw a filled rectangle on a PIL image.

    Args:
        img: The PIL image on which to draw.
        pt1: Top-left coordinates.
        pt2: Bottom-right coordinates.
        color: RGB color tuple.
    """
    draw = ImageDraw.Draw(img)
    draw.rectangle([pt1, pt2], fill=color)


def draw_hollow_rectangle(
    img: Image.Image, pt1: tuple, pt2: tuple, color: tuple, thickness: int = 2
) -> None:
    """
    Draw a hollow rectangle (outlined) on a PIL image.

    Args:
        img: The PIL image on which to draw.
        pt1: Top-left coordinates.
        pt2: Bottom-right coordinates.
        color: RGB color tuple.
        thickness: Outline thickness.
    """
    draw = ImageDraw.Draw(img)
    draw.rectangle([pt1, pt2], outline=color, width=thickness)


def draw_filled_triangle(img: Image.Image, points: list, color: tuple) -> None:
    """
    Draw a filled triangle on a PIL image.

    Args:
        img: The PIL image on which to draw.
        points: A list of three (x, y) tuples representing the triangle vertices.
        color: RGB color tuple.
    """
    draw = ImageDraw.Draw(img)
    draw.polygon(points, fill=color)


def draw_hollow_triangle(
    img: Image.Image, points: list, color: tuple, thickness: int = 2
) -> None:
    """
    Draw a hollow triangle (outlined) on a PIL image.

    Args:
        img: The PIL image on which to draw.
        points: A list of three (x, y) tuples representing the triangle vertices.
        color: RGB color tuple.
        thickness: Outline thickness.
    """
    draw = ImageDraw.Draw(img)
    # Draw lines connecting the vertices and close the triangle
    num_points = len(points)
    for idx in range(num_points):
        p1 = points[idx]
        p2 = points[(idx + 1) % num_points]
        draw.line([p1, p2], fill=color, width=thickness)


def get_random_triangle_points(x_min: int, y_min: int, x_max: int, y_max: int) -> list:
    """
    Generate vertices for an equilateral triangle within specified bounds.

    Args:
        x_min: Minimum x-coordinate.
        y_min: Minimum y-coordinate.
        x_max: Maximum x-coordinate.
        y_max: Maximum y-coordinate.

    Returns:
        List of three (x, y) tuples representing triangle vertices.
    """
    available: int = min(x_max - x_min, y_max - y_min)
    if available < SHAPE_MIN_TRI_SIZE:
        side_length: int = available
    else:
        side_length = random.randint(
            SHAPE_MIN_TRI_SIZE, min(available, SHAPE_MAX_TRI_SIZE)
        )
    # Height for an equilateral triangle
    height: float = side_length * sqrt(3) / 2

    try:
        center_x: int = random.randint(
            int(x_min + side_length / 2), int(x_max - side_length / 2)
        )
    except ValueError:
        center_x = (x_min + x_max) // 2
    try:
        center_y: int = random.randint(int(y_min + height / 2), int(y_max - height / 2))
    except ValueError:
        center_y = (y_min + y_max) // 2

    top: tuple = (center_x, int(center_y - 2 * height / 3))
    bottom_left: tuple = (int(center_x - side_length / 2), int(center_y + height / 3))
    bottom_right: tuple = (int(center_x + side_length / 2), int(center_y + height / 3))
    return [top, bottom_left, bottom_right]


def generate_2d_shapes(draw_all_targets: bool = True) -> tuple:
    """
    Generate synthetic 2D RGB images with non-overlapping shapes using PIL.

    Two images are created:
      - The input image: shapes drawn with their individual colors plus smooth noise.
      - The target image: shapes redrawn using group-average colors.
          If draw_all_targets is False, a filtering is applied so that only shapes whose input colors satisfy
          the channel criteria (triangle: red > 128, rectangle: green >= 128, circle: blue >= 128)
          are drawn in the target image.

    Args:
        draw_all_targets: Flag indicating whether all shapes are drawn in the target image (True)
                          or if a channel filter is applied (False).

    Returns:
        A tuple (input_img, target_img) as PIL Image objects.
    """
    # Create blank images using PIL (black background)
    input_img: Image.Image = Image.new("RGB", (IMAGE_WIDTH, IMAGE_HEIGHT), (0, 0, 0))
    target_img: Image.Image = Image.new("RGB", (IMAGE_WIDTH, IMAGE_HEIGHT), (0, 0, 0))

    shape_logs: list = []  # Store shape properties for later use.
    placed_regions: list = []  # Keep track of occupied regions to avoid overlap.

    # Randomly select 3 or 4 distinct shape types.
    num_shape_types: int = random.randint(3, 4)
    shape_types: list = random.sample(ALLOWED_SHAPES, num_shape_types)

    # Generate occurrences for each selected shape type.
    for shape_type in shape_types:
        num_occurrences: int = random.randint(1, 3)
        for _ in range(num_occurrences):
            placed: bool = False
            attempts: int = 0
            # Try placing the shape until no overlap or maximum attempts reached.
            while not placed and attempts < 100:
                if "triangle" in shape_type:
                    w: int = random.randint(SHAPE_MIN_TRI_SIZE, SHAPE_MAX_TRI_SIZE)
                    h: int = int(w * sqrt(3) / 2)
                    x: int = random.randint(0, IMAGE_WIDTH - w)
                    y: int = random.randint(0, IMAGE_HEIGHT - h)
                    points: list = get_random_triangle_points(x, y, x + w, y + h)
                    new_region: tuple = (x, y, x + w, y + h)
                    params: dict = {"points": points}
                elif "circle" in shape_type:
                    radius: int = random.randint(SHAPE_MIN_RADIUS, SHAPE_MAX_RADIUS)
                    center_x: int = random.randint(radius, IMAGE_WIDTH - radius)
                    center_y: int = random.randint(radius, IMAGE_HEIGHT - radius)
                    new_region = (
                        center_x - radius,
                        center_y - radius,
                        center_x + radius,
                        center_y + radius,
                    )
                    params = {"center": (center_x, center_y), "radius": radius}
                else:  # rectangle case
                    w: int = random.randint(SHAPE_MIN_RECT_SIZE, SHAPE_MAX_RECT_SIZE)
                    h: int = random.randint(SHAPE_MIN_RECT_SIZE, SHAPE_MAX_RECT_SIZE)
                    x: int = random.randint(0, IMAGE_WIDTH - w)
                    y: int = random.randint(0, IMAGE_HEIGHT - h)
                    new_region = (x, y, x + w, y + h)
                    params = {"pt1": (x, y), "pt2": (x + w, y + h)}

                if not is_overlapping(new_region, placed_regions):
                    placed_regions.append(new_region)
                    color_template: tuple = random.choice(ALLOWED_COLORS_TEMPLATE)
                    color: tuple = get_varied_color(color_template)
                    thickness: int = (
                        random.randint(
                            SHAPE_HOLLOW_MIN_THICKNESS, SHAPE_HOLLOW_MAX_THICKNESS
                        )
                        if "hollow" in shape_type
                        else -1
                    )
                    shape_logs.append(
                        {
                            "type": shape_type,
                            "params": params,
                            "color": color,
                            "region": new_region,
                            "thickness": thickness,
                        }
                    )
                    placed = True
                attempts += 1

    # When filtering is applied, ensure at least one shape per group satisfies the criteria.
    if not draw_all_targets:
        valid_criteria = {
            "triangle": lambda c: c[0] > 128,  # Triangle: red channel > 128
            "rectangle": lambda c: c[1] >= 128,  # Rectangle: green channel >= 128
            "circle": lambda c: c[2] >= 128,  # Circle: blue channel >= 128
        }
        valid_colors = {
            "triangle": (255, 0, 0),
            "rectangle": (0, 255, 0),
            "circle": (0, 0, 255),
        }
        shape_groups = {"triangle": [], "rectangle": [], "circle": []}
        for idx, log in enumerate(shape_logs):
            for group in shape_groups:
                if group in log["type"]:
                    shape_groups[group].append(idx)
                    break
        for group, indices in shape_groups.items():
            if indices:
                if not any(
                    valid_criteria[group](shape_logs[i]["color"]) for i in indices
                ):
                    idx = random.choice(indices)
                    shape_logs[idx]["color"] = valid_colors[group]

    # Draw shapes on the input image.
    for log in shape_logs:
        shape_type: str = log["type"]
        color: tuple = log["color"]
        params: dict = log["params"]
        thickness: int = log["thickness"]

        if "triangle" in shape_type:
            if "hollow" in shape_type:
                draw_hollow_triangle(input_img, params["points"], color, thickness)
            else:
                draw_filled_triangle(input_img, params["points"], color)
        elif "circle" in shape_type:
            if "hollow" in shape_type:
                draw_hollow_circle(
                    input_img, params["center"], params["radius"], color, thickness
                )
            else:
                draw_filled_circle(input_img, params["center"], params["radius"], color)
        elif "rectangle" in shape_type:
            if "hollow" in shape_type:
                draw_hollow_rectangle(
                    input_img, params["pt1"], params["pt2"], color, thickness
                )
            else:
                draw_filled_rectangle(input_img, params["pt1"], params["pt2"], color)

    # Add smooth noise to the input image.
    input_img = add_noise(input_img, noise_std=SHAPE_NOISE_STD, sigma=SHAPE_NOISE_SIGMA)

    # Compute group-average colors for each shape type.
    group_avgs: dict = {}
    group_counts: dict = {}
    for log in shape_logs:
        stype: str = log["type"]
        col: np.ndarray = np.array(log["color"], dtype=np.float32)
        if stype not in group_avgs:
            group_avgs[stype] = col
            group_counts[stype] = 1
        else:
            group_avgs[stype] += col
            group_counts[stype] += 1
    for stype in group_avgs:
        group_avgs[stype] = (group_avgs[stype] / group_counts[stype]).astype(np.uint8)

    # Draw the target image using group-average colors and filtering.
    for log in shape_logs:
        shape_type: str = log["type"]
        params: dict = log["params"]
        avg_color: np.ndarray = group_avgs[shape_type]
        thickness: int = log["thickness"]

        if draw_all_targets:
            draw_this: bool = True
        else:
            if "triangle" in shape_type:
                draw_this = log["color"][0] > 128
            elif "rectangle" in shape_type:
                draw_this = log["color"][1] >= 128
            elif "circle" in shape_type:
                draw_this = log["color"][2] >= 128
            else:
                draw_this = False

        if draw_this:
            if "triangle" in shape_type:
                if "hollow" in shape_type:
                    draw_hollow_triangle(
                        target_img,
                        params["points"],
                        tuple(int(c) for c in avg_color),
                        thickness,
                    )
                else:
                    draw_filled_triangle(
                        target_img, params["points"], tuple(int(c) for c in avg_color)
                    )
            elif "circle" in shape_type:
                if "hollow" in shape_type:
                    draw_hollow_circle(
                        target_img,
                        params["center"],
                        params["radius"],
                        tuple(int(c) for c in avg_color),
                        thickness,
                    )
                else:
                    draw_filled_circle(
                        target_img,
                        params["center"],
                        params["radius"],
                        tuple(int(c) for c in avg_color),
                    )
            elif "rectangle" in shape_type:
                if "hollow" in shape_type:
                    draw_hollow_rectangle(
                        target_img,
                        params["pt1"],
                        params["pt2"],
                        tuple(int(c) for c in avg_color),
                        thickness,
                    )
                else:
                    draw_filled_rectangle(
                        target_img,
                        params["pt1"],
                        params["pt2"],
                        tuple(int(c) for c in avg_color),
                    )

    return input_img, target_img


class Shape2DDataset(torch.utils.data.Dataset):
    """
    PyTorch Dataset for synthetic 2D shape images.

    Each sample is generated on-the-fly using generate_2d_shapes.
    The sample includes:
      - An input image with noise (FloatTensor of shape [C, H, W], scaled to [0, 1]).
      - A target image with group-average colors (FloatTensor of shape [C, H, W], scaled to [0, 1]).
    """

    def __init__(
        self, num_samples: int = 1000, draw_all_targets: bool = True, **kwargs
    ) -> None:
        """
        Initialize the Shape2DDataset.

        Args:
            num_samples: Number of samples to generate.
            draw_all_targets: If True, all shapes are drawn in the target image; if False, channel filtering is applied.
            kwargs: Additional keyword arguments to pass to generate_2d_shapes.
        """
        self.num_samples: int = num_samples
        self.draw_all_targets: bool = draw_all_targets
        self.kwargs: dict = kwargs

    def __len__(self) -> int:
        """Return the total number of samples."""
        return self.num_samples

    def __getitem__(self, idx: int) -> tuple:
        """
        Generate and return a sample from the dataset.

        Args:
            idx: Index of the sample (not used as samples are generated on the fly).

        Returns:
            A tuple (input_tensor, target_tensor) where each is a FloatTensor of shape [C, H, W] scaled to [0, 1].
        """
        inp, target = generate_2d_shapes(
            draw_all_targets=self.draw_all_targets, **self.kwargs
        )
        # Convert PIL images to NumPy arrays then to tensors (convert to CHW format)
        inp_tensor: torch.FloatTensor = (
            torch.FloatTensor(np.array(inp).transpose(2, 0, 1)) / 255.0
        )
        target_tensor: torch.FloatTensor = (
            torch.FloatTensor(np.array(target).transpose(2, 0, 1)) / 255.0
        )
        return inp_tensor, target_tensor


def visualize_sample_2d(draw_all_targets: bool = True) -> None:
    """
    Generate and visualize a single sample from the 2D shapes dataset.

    The input and target images are displayed side-by-side.

    Args:
        draw_all_targets: If True, all shapes are drawn in the target image.
                          If False, only shapes satisfying the channel filters are drawn.
    """
    inp, target = generate_2d_shapes(draw_all_targets=draw_all_targets)

    plt.figure(figsize=(12, 6))
    plt.subplot(1, 2, 1)
    plt.imshow(np.array(inp))
    plt.title("Input Image (with noise)")
    plt.axis("off")

    plt.subplot(1, 2, 2)
    plt.imshow(np.array(target))
    title: str = "Target Image (averaged colors)"
    if not draw_all_targets:
        title += "\nOnly showing shapes with matching color channels"
    plt.title(title)
    plt.axis("off")
    plt.tight_layout()
    plt.show()


if __name__ == "__main__":
    # Example: Visualize sample with all shapes drawn in the target image.
    visualize_sample_2d(draw_all_targets=True)
    # Example: Visualize sample with only color-filtered shapes in the target image.
    visualize_sample_2d(draw_all_targets=False)
